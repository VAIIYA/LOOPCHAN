"use strict";exports.id=4447,exports.ids=[4447],exports.modules={44447:(r,e,t)=>{t.d(e,{NE:()=>l,BV:()=>w,XW:()=>d,nI:()=>y,lJ:()=>c,ku:()=>g,o4:()=>u});var n=t(49788);async function o(r,e,t){try{console.log(`Uploading buffer ${e} to Cloudinary...`),console.log("Buffer size:",r.length,"MIME type:",t);let o=await new Promise((t,o)=>{n.v2.uploader.upload_stream({public_id:`loopchan/${e}`,resource_type:"raw",folder:"loopchan",use_filename:!0,unique_filename:!0},(r,e)=>{r?(console.error("Cloudinary upload error:",r),o(r)):(console.log("Cloudinary upload success:",e),t(e))}).end(r)});if(o&&"object"==typeof o&&"secure_url"in o)return{success:!0,url:o.secure_url,publicId:o.public_id,fileName:e};throw Error("Invalid upload response from Cloudinary")}catch(r){throw console.error("Cloudinary buffer upload error:",r),r}}n.v2.config({cloud_name:process.env.CLOUDINARY_CLOUD_NAME,api_key:process.env.CLOUDINARY_API_KEY,api_secret:process.env.CLOUDINARY_API_SECRET});let a=["2Z9eW3nwa2GZUM1JzXdfBK1MN57RPA2PrhuTREEZ31VY"];async function i(r){try{if(a.includes(r))return!0;return(await c()).includes(r)}catch(r){return console.error("Error checking free wallet status:",r),!1}}async function c(){try{if(!process.env.CLOUDINARY_CLOUD_NAME)return console.error("Cloudinary not configured"),a;try{return a}catch(r){return console.error("Error getting free wallets:",r),a}}catch(r){return console.error("Error getting free wallets:",r),a}}async function s(r){try{if(!process.env.CLOUDINARY_CLOUD_NAME)throw Error("Cloudinary not configured");let e={wallets:r,lastUpdated:new Date().toISOString()},t=Buffer.from(JSON.stringify(e),"utf8");await o(t,"free_wallets.json","application/json")}catch(r){throw console.error("Error saving free wallets:",r),r}}async function l(r){try{let e=await c();e.includes(r)||(e.push(r),await s(e))}catch(r){throw console.error("Error adding free wallet:",r),r}}async function u(r){try{let e=(await c()).filter(e=>e!==r);await s(e)}catch(r){throw console.error("Error removing free wallet:",r),r}}async function f(r){try{let e=await p(r);if(!e)return!1;if("free"===e.type)return!0;if("paid"===e.type&&e.endDate){let r=new Date(e.endDate),t=new Date;return r>t&&e.isActive}return!1}catch(r){return console.error("Error checking subscription status:",r),!1}}async function p(r){try{if(await i(r))return{walletAddress:r,type:"free",startDate:new Date().toISOString(),isActive:!0};if(!process.env.CLOUDINARY_CLOUD_NAME)return console.error("Cloudinary not configured"),null;try{return null}catch(r){return null}}catch(r){return console.error("Error getting subscription:",r),null}}async function d(r,e=.99){try{let t=new Date,n=new Date(t.getTime()+26784e5),a={walletAddress:r,type:"paid",startDate:t.toISOString(),endDate:n.toISOString(),paymentAmount:e,isActive:!0};if(!process.env.CLOUDINARY_CLOUD_NAME)throw Error("Cloudinary not configured");let i=[];try{i=[]}catch(r){i=[]}let c=i.findIndex(e=>e.walletAddress===r);c>=0?i[c]=a:i.push(a);let s={subscriptions:i,lastUpdated:new Date().toISOString()},l=Buffer.from(JSON.stringify(s),"utf8");return await o(l,"paid_subscriptions.json","application/json"),a}catch(r){throw console.error("Error creating subscription:",r),r}}async function y(){try{return process.env.CLOUDINARY_CLOUD_NAME||console.error("Cloudinary not configured"),[]}catch(r){return console.error("Error getting all subscriptions:",r),[]}}async function w(r){try{if(await i(r))return!0;return await f(r)}catch(r){return console.error("Error checking reply permission:",r),!1}}async function g(r){try{if(await i(r))return{canReply:!0,type:"free"};let e=await p(r);if(e&&"paid"===e.type&&e.endDate){let r=new Date(e.endDate),t=new Date,n=Math.ceil((r.getTime()-t.getTime())/864e5);return{canReply:n>0&&e.isActive,type:"paid",daysRemaining:Math.max(0,n),endDate:e.endDate}}return{canReply:!1,type:"none"}}catch(r){return console.error("Error getting subscription status:",r),{canReply:!1,type:"none"}}}}};